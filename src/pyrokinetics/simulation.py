from collections import Counter
from pathlib import Path
from typing import Optional, Union

from typing_extensions import Self

from .local_geometry import LocalGeometry
from .local_species import LocalSpecies
from .normalisation import ConstNormalisation
from .numerics import Numerics
from .typing import PathLike

__all__ = ["LocalGKSimulation"]


class LocalGKSimulation:

    _base_name: str
    _name: str
    _norms: ConstNormalisation
    _geometry: LocalGeometry
    _species: LocalSpecies
    _numerics: Numerics

    _RUN_NAMES = Counter()

    def __init__(
        self,
        base_name: str,
        name: str,
        norms: ConstNormalisation,
        geometry: LocalGeometry,
        species: LocalSpecies,
        numerics: Numerics,
    ) -> None:
        """Describes a gyrokinetics simulation in a self-consistent manner.

        Gyrokinetics simulations are typically defined in terms of normalised
        units. This means that modifying one aspect of a simulation can
        necessitate modifications elsewhere to maintain consistency. For
        example, modifying the minor radius of the flux surface may change the
        reference length against which many other quanitities are defined, such
        as spatial derivatives.

        This class is used to ensure that modifications to one aspect of a
        simulation, such as the geometry or species under study, are reflected
        in the others. It achieves this by generating a new system of reference
        units at each modification, and converting all components to match.
        Instances should be considered immutable, and each modification should
        generate a new instance.

        It is recommended to build new instances using the class method
        :method:`LocalGKSimulation.new` instead of the basic ``__init__``
        function.

        TODO the preferred interface in future should be ``read_gk_input``.

        Parameters
        ----------
        base_name
            A reference name for the simulation.
        name
            The ``base_name`` with a unique number code. This should be
            generated by :method:`LocalGKSimulation._unique_name`.
        geometry
            Describes the parameterisation of the simulation's flux surface.
            Should be set up to match with ``norms`` in advance.
        species
            Includes information such as mass, charge, and temperature for each
            species. Should be set up to match with ``norms`` in advance.
        numerics
            Describes non-physical aspects of the simulation, such as grid
            dimensions. Should be set up to match with ``norms`` in advance.
        norms
            The system of normalised units shared by all components of the
            simulation.
        """
        if not self._check_name(name, base_name):
            raise ValueError(f"Name {name} does not match base name {base_name}")
        self._base_name = base_name
        self._name = name
        self._norms = norms
        self._geometry = geometry
        self._species = species
        self._numerics = numerics

    @classmethod
    def new(
        cls,
        geometry: LocalGeometry,
        species: LocalSpecies,
        numerics: Numerics,
        convention: str,
        name: str = "pyro",
        ion_reference_species: str = "deuterium",
    ) -> Self:
        """Build a new
        Parameters
        ----------
        geometry
            Describes the parameterisation of the simulation's flux surface.
        species
            Includes information such as mass, charge, and temperature for each
            species.
        numerics
            Describes non-physical aspects of the simulation, such as grid
            dimensions.
        convention
            The system of normalised units shared by all components of the
            simulation.
        name
            A reference name for this simulation. Any physical units will
            include this reference along with a unique number code.
        ion_reference_species
            The name of the ion species used as a temperature/density/mass
            reference. If it matches the name of an ion species in ``species``,
            everything in units of ``tref_ion``, ``nref_ion`` or ``mref_ion``
            will be normalised relative to that species. If it doesn't match
            any named species in ``species``, we assume that the reference
            temperature, density, and mass of that species is one. This may be
            useful when species are specified in reference to deuterium, but
            deuterium is not being simulated directly. We assume that there
            will only ever be one negatively charged species, which should
            always be called "electron".
        """
        base_name = name
        name = cls._unique_name(name)

        # Create set of normalised units
        electron = species["electron"]
        ion = species[ion_reference_species]

        norms = ConstNormalisation(
            name=name,
            convention=convention,
            B0=geometry.B0,
            bunit_over_b0=geometry.bunit_over_b0,
            minor_radius=geometry.a_minor,
            aspect_ratio=geometry.Rmaj / geometry.a_minor,
            electron_temperature=electron["temp"],
            ion_temperature=ion["temp"],
            electron_density=electron["dens"],
            ion_density=ion["dens"],
            electron_mass=electron["mass"],
            ion_mass=ion["mass"],
            ion_species=ion_reference_species,
        )

        # Apply units to each component
        geometry = geometry.with_units(norms)
        species = species.with_units(norms)
        numerics = numerics.with_units(norms)
        return cls(base_name, name, norms, geometry, species, numerics)

    def to_convention(self, convention: str) -> Self:
        """Creates a copy with a new units convention."""
        base_name = self._base_name
        name = self._unique_name(self._base_name)
        norms = self._norms.with_convention(convention.lower(), name=name)
        geometry = self._geometry.with_units(norms)
        species = self._species.with_units(norms)
        numerics = self._numerics.with_units(norms)
        return self.__class__(base_name, name, norms, geometry, species, numerics)

    def to_gk_code(self, gk_code: str) -> Self:
        """Alias to :method:`LocalGKSimulation:to_convention`."""
        return self.to_convention(convention=gk_code)

    def with_geometry(self, geometry: LocalGeometry) -> Self:
        """Creates a new simulation with modified geometry parameters."""
        base_name = self._base_name
        name = self._unique_name(self._base_name)
        norms = self._norms.with_geometry_params(
            name=name,
            B0=geometry.B0,
            bunit_over_b0=geometry.bunit_over_b0,
            minor_radius=geometry.a_minor,
            aspect_ratio=geometry.Rmaj / geometry.a_minor,
        )
        new_geometry = geometry.with_units(norms)
        species = self._species.with_units(norms)
        numerics = self._numerics.with_units(norms)
        return self.__class__(base_name, name, norms, new_geometry, species, numerics)

    def with_species(
        self, species: LocalSpecies, ion_reference_species: Optional[str] = None
    ) -> Self:
        """Creates a new simulation with modified species parameters."""
        base_name = self._base_name
        name = self._unique_name(self._base_name)
        if ion_reference_species is None:
            ion_reference_species = self._norms.ion_species
        electron = species["electron"]
        ion = species[ion_reference_species]
        norms = self._norms.with_species_params(
            name=name,
            electron_temperature=electron["temp"],
            ion_temperature=ion["temp"],
            electron_density=electron["dens"],
            ion_density=ion["dens"],
            electron_mass=electron["mass"],
            ion_mass=ion["mass"],
            ion_species=ion_reference_species,
        )
        new_species = species.with_units(norms)
        geometry = self._geometry.with_units(norms)
        numerics = self._numerics.with_units(norms)
        return self.__class__(base_name, name, norms, geometry, new_species, numerics)

    @classmethod
    def _unique_name(cls, name: Union[str, PathLike]) -> str:
        """Return a unqiuely numbered run name from `name`"""
        # name might be a Path, in which case just use the filename
        # (without extension)
        name = Path(name).stem
        name = "".join([ch for ch in name if ch.isalpha() or ch.isdigit() or ch == "_"])
        new_name = f"{name}{cls._RUN_NAMES[name]:06}"
        cls._RUN_NAMES[name] += 1
        return new_name

    @staticmethod
    def _check_name(name: str, base_name: str) -> bool:
        """Ensure a simulation name is of the correct format.

        ``name`` should be a string generated by the class method
        :method:`LocalGKSimulation._unique_name`.
        """
        # Seems to handle strings smaller than 6 characters just fine
        return name[:-6] == base_name and name[-6:].isdigit()
